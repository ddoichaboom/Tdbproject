# TDB 스마트 약 배출 시스템 - 프로젝트 명세서

## 1. 프로젝트 개요

### 1.1 프로젝트 명
**TDB (Time-based Drug Dispenser)** - 시간대별 자동 약 배출 시스템

### 1.2 목적
가정용 자동 약 배출 시스템으로, RFID 카드를 이용해 사용자를 인식하고 개인별 복약 스케줄에 따라 정확한 시간대(아침/점심/저녁)에 맞춰 약을 자동으로 배출하는 IoT 헬스케어 솔루션입니다.

### 1.3 주요 특징
- **RFID 기반 사용자 인식**: MFRC522 리더를 통한 비접촉 카드 인식
- **시간대별 배출**: 회전판(carousel) 메커니즘으로 아침/점심/저녁 약 분리 배출
- **실시간 대시보드**: 2x3 타일 형식의 현대적인 GUI (Tkinter)
- **클라우드 연동**: NestJS 백엔드 서버와 실시간 동기화
- **오프라인 내구성**: 네트워크 장애 시 로컬 큐잉 및 자동 재전송
- **다중 사용자 지원**: 가족 구성원별 개별 스케줄 관리

---

## 2. 시스템 아키텍처

### 2.1 전체 구성도

```
┌─────────────────────────────────────────────────────────────┐
│                    라즈베리파이 (Python)                      │
│  ┌──────────────┐         ┌─────────────────────────────┐  │
│  │ main.py      │◄───────►│ DashboardApp (Tkinter GUI)  │  │
│  │ (통합 부트스트랩)│         │ - 2x3 타일 레이아웃          │  │
│  └──────┬───────┘         │ - QR 코드 팝업              │  │
│         │                 │ - 실시간 상태 표시          │  │
│         │                 └─────────────────────────────┘  │
│         ↓                                                  │
│  ┌──────────────────────────────────────────────────┐      │
│  │ SerialReaderAdapter (이벤트 브릿지)                │      │
│  └──────────────┬───────────────────────────────────┘      │
│                 ↓                                          │
│  ┌──────────────────────────────────────────────────┐      │
│  │ serial_reader.py (핵심 비즈니스 로직)              │      │
│  │ - RFID UID 폴링                                   │      │
│  │ - 사용자 인증 (resolve_uid)                       │      │
│  │ - 배출 큐 생성 (build_queue)                      │      │
│  │ - 회전판 제어 + 약 배출                           │      │
│  │ - 배출 완료 보고 (report_dispense)                │      │
│  └──────────┬───────────────────┬───────────────────┘      │
│             ↓                   ↓                          │
│  ┌──────────────────┐  ┌────────────────────┐             │
│  │ arduino_link.py  │  │ api_client.py      │             │
│  │ (시리얼 통신)      │  │ (HTTP 클라이언트)   │             │
│  └────────┬─────────┘  └────────┬───────────┘             │
└───────────┼─────────────────────┼──────────────────────────┘
            ↓                     ↓
    ┌───────────────┐    ┌────────────────────┐
    │ Arduino Mega  │    │ NestJS 백엔드 서버  │
    │ (C++ 펌웨어)   │    │ (EC2 + RDS MySQL)  │
    │               │    │                    │
    │ - MFRC522     │    │ - 사용자 관리       │
    │ - 서보 모터    │    │ - 스케줄 관리       │
    │ - 솔레노이드   │    │ - 재고 관리        │
    └───────────────┘    │ - 배출 기록        │
                         └────────────────────┘
```

### 2.2 하드웨어 구성

#### 라즈베리파이 (Python 클라이언트)
- **OS**: Raspberry Pi OS (Linux)
- **역할**:
  - RFID 리더 인터페이스
  - Arduino와 시리얼 통신 (9600 baud)
  - 백엔드 서버 API 호출
  - GUI 대시보드 표시
- **주요 라이브러리**:
  - `pyserial` - Arduino 시리얼 통신
  - `requests` - HTTP API 클라이언트
  - `tkinter` - GUI 프레임워크
  - `qrcode`, `Pillow` - QR 코드 생성 및 이미지 처리

#### Arduino Mega
- **플랫폼**: ATmega2560 (PlatformIO)
- **역할**:
  - MFRC522 RFID 리더 제어
  - 서보 모터 제어 (회전판 구동)
  - 솔레노이드 릴레이 제어 (약 배출)
- **주요 라이브러리**:
  - `MFRC522` - RFID 리더
  - `Servo` - 서보 모터 제어
- **핀 구성**:
  - 슬롯별 로딩 솔레노이드 (Active-Low)
  - 슬롯별 배출 솔레노이드 (Active-Low)
  - 2개의 연속 회전 서보 모터

---

## 3. 소프트웨어 구조

### 3.1 라즈베리파이 클라이언트 (Python)

#### 3.1.1 main.py (통합 부트스트랩)
- **역할**: GUI와 시리얼 리더를 단일 프로세스로 통합
- **기능**:
  - `--demo` 플래그로 데모 모드 지원 (하드웨어 없이 테스트)
  - GUI 이벤트 콜백 등록
  - 10초 주기 서버 데이터 폴링 (사용자/재고/스케줄/기록)
  - 시리얼 준비 완료 감지 및 폴링 스레드 시작

**주요 콜백**:
```python
- on_waiting(): RFID 대기 상태
- on_uid(uid): RFID 카드 감지
- on_error(msg): 오류 발생
- on_unregistered(device_id): 기기 미등록 → QR 표시
- on_kit_unregistered(uid): 카드 미등록 → QR 표시
- on_status_update(tile_index, msg): 타일 상태 업데이트
```

#### 3.1.2 hwserial/serial_reader.py (핵심 비즈니스 로직)
- **역할**: RFID 기반 약 배출 프로세스의 핵심 상태 머신
- **주요 함수**:

**`main(adapter)`**:
```python
1. 기기 등록 확인 (check_machine_registered)
   → 미등록 시 QR 코드 표시하며 대기

2. 시리얼 포트 열기 (open_serial)

3. 메인 루프:
   - 주기적 하트비트 (기본 5분, 설정 가능)
   - RFID UID 읽기 (read_uid_once)
   - UID 쿨다운 (2초, 중복 스캔 방지)
   - 세션 잠금 (배출 중 다른 카드 무시)

4. UID 처리:
   - resolve_uid(): 사용자 확인
   - 미등록 → kit_not_registered QR 표시
   - took_today=1 → "이미 복용 완료" 안내

5. 배출 프로세스:
   - build_queue(): 서버에서 스케줄 조회
   - process_queue(): 시간대별 배출 실행
   - 각 시간대 완료 시 report_dispense() 호출
```

**`process_queue(machine_id, user_id, phases, ser, adapter)`**:
```python
phases: [
  {"time": "morning", "items": [{"slot": 1, "medi_id": "M123", "count": 2}]},
  {"time": "afternoon", "items": [...]},
  {"time": "evening", "items": [...]}
]

로직:
1. 시간대별 정렬 (morning → afternoon → evening)
2. 각 시간대마다:
   - 회전판 이동 (step_next_n)
     * stage 0 → 1: 2000ms 전진
     * stage 1 → 2: 2500ms 전진
   - 슬롯별 배출 (dispense)
     * 로딩 솔레노이드 1초 ON → 0.3초 대기
     * 배출 솔레노이드 1초 ON → 0.3초 대기
   - 서버 리포트 (report_dispense)
     * 성공 시 즉시 전송
     * 실패 시 offline_reports.jsonl에 저장
3. 전체 완료 후 HOME 복귀 (step_home)
```

**상태 파일** (`data/state.json`):
```json
{
  "status": "waiting_uid | resolving_uid | queue_ready | dispensing | done | error",
  "last_uid": "6CEFECBF",
  "phase": "morning | afternoon | evening",
  "progress": {"morning": true, "afternoon": false, "evening": false},
  "error": null,
  "ts": 1701234567.89
}
```

#### 3.1.3 hwserial/arduino_link.py (시리얼 통신 프로토콜)
- **자동 포트 감지**: Arduino 제조사 정보로 `/dev/ttyACM*` 탐색
- **명령 전송**:
  ```
  DISPENSE,<slot>,<count>  → OK,<slot>,<count> 또는 ERR,<reason>
  STEP,NEXT                → OK,STEP,NEXT
  HOME                     → OK,HOME
  JOG,<F|B>,<ms>[,speed]   → OK,JOG (긴급 복구용)
  ```
- **UID 읽기**: `read_uid_once()` - 8자리 이상 16진수 필터링
- **재시도 메커니즘**: `_send_cmd_wait()` - 5초 타임아웃

#### 3.1.4 services/api_client.py (백엔드 API 클라이언트)
- **HTTP 세션**: `requests.Session` + `urllib3.Retry` (3회 자동 재시도)
- **백오프**: 0.5초 exponential backoff
- **API 엔드포인트**:

```python
# 기기 관리
GET  /machine/check?machine_id=<id>
POST /machine/heartbeat
GET  /machine/{id}/users
GET  /machine/{id}/slots
GET  /machine/{id}/schedules/today

# RFID 인증
POST /rfid/resolve {"uid": "6CEFECBF"}
  → {"registered": true, "user_id": "U001", "took_today": 0}

# 배출 큐 생성
POST /queue/build {
  "machine_id": "MACHINE-0001",
  "user_id": "U001",
  "client_ts": 1701234567,
  "tz_offset_min": 540  # KST
}
  → {"status": "ok", "queue": [...]}

# 배출 완료 보고
POST /dispense/report {
  "machine_id": "MACHINE-0001",
  "user_id": "U001",
  "time": "morning",
  "items": [{"medi_id": "M123", "slot": 1, "count": 2}],
  "result": "completed"
}

# 배출 기록 조회
GET  /dose-history/machine/{id}?start_date=2024-12-01
```

#### 3.1.5 gui/gui_app.py (대시보드 GUI)
- **프레임워크**: Tkinter + ttk (다크 테마)
- **레이아웃**: 2행 × 3열 타일 (800x480px, 전체화면 지원)

**타일 구성**:
```
┌─────────────┬─────────────┬─────────────┐
│ [0] 현재시간 │ [1] 재고현황 │ [2] 스케줄  │
│  2024-12-06 │  Slot 1:    │  아침: ...  │
│  21:05:32   │   비타민C   │  점심: ...  │
│             │   80/100    │  저녁: ...  │
├─────────────┼─────────────┼─────────────┤
│ [3] 배출상태 │ [4] 최근기록 │ [5] 유저목록│
│ RFID 대기중 │ 홍길동님    │ 홍길동(보호자)│
│             │ 12/05 복용  │ 김철수      │
└─────────────┴─────────────┴─────────────┘
```

**팝업 시스템**:
- `show_popup(title, msg)`: 텍스트 알림
- `show_qr_popup(qr_data, title, msg)`: QR 코드 표시 (300x300px)
  - 기기 등록: `TDB_{DEVICE_UID}`
  - 카드 등록: `TDB_KIT_{UID}`
- `hide_popup()`: 팝업 숨기기

**스레드 안전성**: `ui_call()` 메서드로 메인 스레드에서 UI 업데이트 보장

#### 3.1.6 config/settings.py (환경 설정)
- **환경 변수 로딩**: `config/.env` 파일 자동 파싱
- **주요 설정**:
  ```bash
  TDB_SERVER_BASE_URL=http://your-server:3000
  TDB_MACHINE_ID=MACHINE-0001
  TDB_DEVICE_UID=DEVICE-UUID-001
  TDB_SERIAL_PORT=/dev/ttyACM0  # 자동 감지 시 생략
  TDB_BAUDRATE=9600
  TDB_UID_COOLDOWN_SEC=2.0
  TDB_HEARTBEAT_SEC=300
  ```

---

### 3.2 Arduino Mega 펌웨어 (C++)

#### 3.2.1 firmware/src/main.cpp
- **초기화** (`setup()`):
  - SPI/MFRC522 초기화
  - 서보 모터 중립 위치 설정
  - 솔레노이드 핀 HIGH (Active-Low → OFF 상태)
  - `READY` 메시지 전송

- **메인 루프** (`loop()`):
  1. RFID 카드 감지 → UID 대문자 16진수로 시리얼 출력
  2. 시리얼 명령 처리 (`handleSerialCommand()`)

- **명령 처리**:
  ```cpp
  DISPENSE,<slot>,<count>:
    - dispenseSlot() 호출
    - 로딩 솔레노이드 LOW(ON) 1초 → HIGH(OFF) 0.3초
    - 배출 솔레노이드 LOW(ON) 1초 → HIGH(OFF) 0.3초
    - count 횟수만큼 반복

  STEP,NEXT:
    - servoStepNext() 호출
    - stage 0→1: 2000ms 전진
    - stage 1→2: 2500ms 전진

  HOME:
    - servoReturnHome() 호출
    - stage 2→1: 2500ms 후진
    - stage 1→0: 2000ms 후진

  JOG,<F|B>,<ms>[,speed]:
    - 긴급 수동 조작 (100~15000ms)
    - 속도: 0~100% (기본 50%)

  TEST_SOLENOID,<slot>,<L|D|B>:
    - L: 로딩 솔레노이드 테스트
    - D: 배출 솔레노이드 테스트
    - B: 둘 다 테스트
  ```

#### 3.2.2 firmware/src/servos.cpp
- **회전판 제어 로직**:
  ```cpp
  static uint8_t g_servoStage = 0;  // 0=HOME, 1=아침후, 2=점심후

  servoStepNext():
    - stage 0 → 1: 전진 2000ms
    - stage 1 → 2: 전진 2500ms

  servoReturnHome():
    - stage 2 → 1: 후진 2500ms
    - stage 1 → 0: 후진 2000ms
  ```

- **서보 동작**:
  - `servoNeutral()`: 90도 중립 위치
  - `servoMoveFB(dir, speed, ms)`: 방향(F/B), 속도(%), 시간(ms) 제어
  - 동작 후 `detach()`로 전원 절약

#### 3.2.3 firmware/platformio.ini
```ini
[env:megaatmega2560]
platform = atmelavr
board = megaatmega2560
framework = arduino
lib_deps =
  miguelbalboa/MFRC522
  arduino-libraries/Servo
upload_protocol = stk500v2
monitor_speed = 9600
```

---

### 3.3 백엔드 서버 (NestJS + MySQL)

**주의**: `tdb_server/` 디렉토리는 EC2 서버 코드의 로컬 클론으로, 참고용입니다.

#### 주요 API 엔드포인트
- **인증 없음**: 라즈베리파이 API는 현재 JWT 인증 미적용 (IP 화이트리스트 권장)
- **데이터베이스**: AWS RDS MySQL 8.0.42
- **주요 테이블**:
  - `users`: 사용자 정보, RFID UID 매핑 (`k_uid`)
  - `user_group`: 가족 그룹
  - `machine`: 디스펜서 기기 정보
  - `machine_slot`: 슬롯별 약품 및 재고
  - `medicine`: 약품 마스터 데이터
  - `schedule`: 요일별 복약 스케줄
  - `dose_history`: 배출 완료 기록

---

## 4. 주요 프로세스 플로우

### 4.1 사용자 약 배출 시나리오

```
1. 시스템 부팅
   ├─ main.py 실행 (GUI + Serial Reader)
   ├─ 기기 등록 확인
   │  └─ 미등록 시: QR 코드 표시
   └─ waiting_uid 상태 전환

2. RFID 카드 태그
   ├─ Arduino가 UID 읽어 시리얼 전송 (예: "6CEFECBF")
   ├─ serial_reader.py가 수신
   ├─ UID 쿨다운 확인 (2초 이내 중복 무시)
   └─ resolve_uid() 호출

3. 사용자 인증
   ├─ 서버 응답:
   │  ├─ registered=false → kit_not_registered QR 표시
   │  ├─ took_today=1 → "이미 복용 완료" 안내
   │  └─ 정상 인증 성공
   └─ 세션 잠금 (_session_user_id 설정)

4. 스케줄 조회
   ├─ build_queue(machine_id, user_id) 호출
   ├─ 서버가 시간대별 배출 목록 반환
   │  └─ [{"time": "morning", "items": [...]}, ...]
   └─ 빈 큐 → "배출할 약 없음" 안내

5. 약 배출 프로세스
   ├─ [아침약 배출]
   │  ├─ STEP,NEXT → stage 0에서 유지 (이미 HOME)
   │  ├─ DISPENSE,1,2 (슬롯 1에서 2정)
   │  ├─ DISPENSE,3,1 (슬롯 3에서 1정)
   │  └─ report_dispense(time="morning")
   │
   ├─ [점심약 배출]
   │  ├─ STEP,NEXT → stage 0→1 (2000ms 전진)
   │  ├─ DISPENSE,2,1 (슬롯 2에서 1정)
   │  └─ report_dispense(time="afternoon")
   │
   ├─ [저녁약 배출]
   │  ├─ STEP,NEXT → stage 1→2 (2500ms 전진)
   │  ├─ DISPENSE,1,1 (슬롯 1에서 1정)
   │  └─ report_dispense(time="evening")
   │
   └─ HOME → stage 2→0 (4500ms 후진)

6. 배출 완료
   ├─ state.json 업데이트 (status="done")
   ├─ GUI 타일 업데이트 ("배출 완료!")
   ├─ 3초 대기
   └─ 세션 잠금 해제 → waiting_uid 복귀
```

### 4.2 오프라인 내구성 메커니즘

```
배출 완료 보고 실패 시:
1. payload를 offline_reports.jsonl에 1줄 저장
   {
     "machine_id": "MACHINE-0001",
     "user_id": "U001",
     "time": "morning",
     "items": [...],
     "result": "completed"
   }

2. 다음 하트비트 시 (5분마다):
   - flush_offline() 호출
   - jsonl 파일 각 줄 읽어서 재전송 시도
   - 성공한 줄은 제거, 실패한 줄은 유지

3. 최종적으로 모든 리포트 전송 보장
```

---

## 5. 개발 환경 및 배포

### 5.1 개발 환경 설정

#### Python 클라이언트
```bash
# 가상환경 생성
python3 -m venv .venv
source .venv/bin/activate

# 의존성 설치
pip install -r requirements.txt
```

#### Arduino 펌웨어
```bash
# PlatformIO 설치 (필요 시)
pip install platformio

# 펌웨어 빌드
cd firmware
pio run

# 업로드
pio run -t upload

# 시리얼 모니터
pio device monitor
```

### 5.2 실행 방법

#### 통합 모드 (권장)
```bash
# 프로덕션 (전체화면)
python main.py

# 데모 모드 (윈도우, 하드웨어 없이 테스트)
python main.py --demo
```

#### 개별 실행 (레거시)
```bash
# 터미널 1: 시리얼 리더
python hwserial/serial_reader.py

# 터미널 2: GUI
python gui/qr_display.py  # 또는 gui/gui_app.py
```

#### 로컬 Mock 서버 (개발용)
```bash
cd dev
uvicorn mock_server:app --reload --port 8000
```

### 5.3 systemd 서비스 (자동 시작)

**현재 설정**: 통합 서비스
```bash
# 상태 확인
sudo systemctl status tdb.service

# 로그 확인
sudo journalctl -u tdb.service -f

# 재시작
sudo systemctl restart tdb.service
```

---

## 6. 주요 디렉토리 구조

```
Tdbproject/
├── main.py                    # 통합 부트스트랩 (GUI + Serial)
├── requirements.txt           # Python 의존성
│
├── config/
│   ├── .env                   # 환경 변수 (서버 URL, 기기 ID 등)
│   └── settings.py            # 환경 변수 로더
│
├── hwserial/
│   ├── serial_reader.py       # 핵심 비즈니스 로직
│   ├── arduino_link.py        # 시리얼 통신 프로토콜
│   └── serial_reader_adapter.py # GUI 이벤트 브릿지
│
├── services/
│   └── api_client.py          # 백엔드 API 클라이언트
│
├── gui/
│   ├── gui_app.py             # 대시보드 GUI (2x3 타일)
│   ├── qr_display.py          # 간단한 QR 표시 GUI (레거시)
│   └── assets/images/         # 약품 이미지 (slot_1.png 등)
│
├── firmware/
│   ├── platformio.ini         # PlatformIO 설정
│   └── src/
│       ├── main.cpp           # RFID 읽기 + 명령 처리
│       ├── servos.cpp         # 회전판 제어
│       ├── hardware.cpp       # 하드웨어 초기화
│       └── *.hpp              # 헤더 파일
│
├── scripts/
│   ├── recovery_jog.py        # 긴급 수동 회전판 조작
│   └── test_solenoid.py       # 솔레노이드 테스트
│
├── data/
│   ├── state.json             # GUI 상태 파일
│   └── offline_reports.jsonl  # 오프라인 큐
│
└── dev/
    └── mock_server.py         # 로컬 테스트용 FastAPI 서버
```

---

## 7. 주요 기능 및 특징

### 7.1 세션 잠금 메커니즘
- **문제**: 배출 중 다른 RFID 카드 인식 시 충돌
- **해결**: `_session_user_id`와 `_active_kit_uid`로 세션 관리
  - 배출 시작 시 설정
  - 배출 완료 시 해제
  - 세션 활성화 중에는 다른 UID 무시

### 7.2 물리적 회전판 맵핑
```
Stage 0 (HOME): 아침약 위치
  ↓ 2000ms 전진
Stage 1: 점심약 위치
  ↓ 2500ms 전진
Stage 2: 저녁약 위치
  ↓ 4500ms 후진 (2500+2000)
Stage 0 (HOME): 복귀 완료
```

### 7.3 UID 쿨다운
- **문제**: RFID 카드를 계속 대고 있으면 중복 인식
- **해결**:
  - `_last_uid`, `_last_ts` 저장
  - 같은 UID + 2초 이내 → 무시

### 7.4 실시간 서버 폴링
- **주기**: 10초마다 (main.py의 `poll_server_data()`)
- **조회 데이터**:
  - 등록된 사용자 목록 → [5] 유저 타일 업데이트
  - 슬롯별 재고 현황 → [1] 재고 타일 업데이트
  - 오늘의 전체 스케줄 → [2] 스케줄 타일 업데이트
  - 최근 배출 기록 → [4] 기록 타일 업데이트

### 7.5 오류 복구 도구

#### recovery_jog.py (긴급 회전판 조작)
```bash
# 앞으로 1초 이동
python scripts/recovery_jog.py --dir F --ms 1000

# 뒤로 0.5초 이동
python scripts/recovery_jog.py --dir B --ms 500

# 다음 단계로
python scripts/recovery_jog.py --step NEXT

# HOME 복귀
python scripts/recovery_jog.py --step HOME
```

#### test_solenoid.py (솔레노이드 테스트)
```bash
# 슬롯 1 로딩 솔레노이드 테스트
python scripts/test_solenoid.py

# Arduino 직접 명령
# pio device monitor
# 입력: TEST_SOLENOID,1,L
```

---

## 8. 보안 및 고려사항

### 8.1 현재 보안 상태
- **라즈베리파이 → 서버**: 인증 없음 (IP 화이트리스트 권장)
- **모바일 앱 → 서버**: JWT Bearer Token 인증

### 8.2 권장 사항
1. **HTTPS 사용**: 프로덕션 환경에서 필수
2. **방화벽 설정**: `/machine`, `/rfid`, `/queue` 경로를 라즈베리파이 IP만 허용
3. **기기 인증**: 향후 기기별 API 키 도입 고려

### 8.3 데이터 개인정보 보호
- RFID UID는 암호화되지 않음 (16진수 원본 전송)
- 사용자 개인정보는 서버 DB에만 저장
- 로컬 state.json에는 UID만 임시 저장

---

## 9. 테스트 및 디버깅

### 9.1 로그 파일
```bash
# 시리얼 리더 로그
tail -f logs/serial_reader.log

# systemd 서비스 로그
sudo journalctl -u tdb.service -f
```

### 9.2 상태 파일 확인
```bash
# 현재 상태
cat data/state.json

# 오프라인 큐
cat data/offline_reports.jsonl
```

### 9.3 Arduino 시리얼 모니터
```bash
cd firmware
pio device monitor

# 직접 명령 테스트
DISPENSE,1,1
STEP,NEXT
HOME
```

---

## 10. 알려진 이슈 및 제약사항

### 10.1 하드웨어 제약
- **솔레노이드 타이밍**: 현재 고정 (로딩 1초, 배출 1초)
  - 약품 크기에 따라 조정 필요할 수 있음
- **회전판 정밀도**: 서보 모터 시간 기반 제어
  - 마모 시 위치 오차 발생 가능
  - 엔코더 센서 추가 권장

### 10.2 소프트웨어 제약
- **동시 사용자**: 1명씩만 처리 (세션 잠금)
  - 가족 구성원이 동시에 카드를 대면 첫 번째만 처리
- **네트워크 의존성**: 서버 다운 시 배출 불가
  - 오프라인 모드 개선 필요

### 10.3 서버 API 호환성
- 서버 버전 업데이트 시 API 경로 변경 가능성
  - `/machine/check` → `/dispenser/machine-status` 등
  - api_client.py 수정 필요

---

## 11. 향후 개선 계획

### 11.1 하드웨어
- [ ] 엔코더 센서 추가 (정밀한 회전판 위치 제어)
- [ ] 약품 감지 센서 (배출 성공 여부 확인)
- [ ] 터치스크린 UI (수동 배출 기능)

### 11.2 소프트웨어
- [ ] 오프라인 모드 완전 지원 (로컬 DB)
- [ ] 음성 안내 기능
- [ ] 원격 모니터링 (모바일 앱 연동)
- [ ] 재고 부족 알림 (SMS/푸시)

### 11.3 보안
- [ ] 기기 인증 (API 키)
- [ ] HTTPS 필수화
- [ ] 감사 로그 (누가 언제 배출했는지)

---

## 12. 라이선스 및 저작권

이 프로젝트는 개인 프로젝트로, 오픈소스 라이브러리를 사용합니다:
- **MFRC522**: LGPL-3.0
- **Arduino Servo**: LGPL-2.1
- **Python 라이브러리들**: 각 라이브러리의 라이선스 참조

---

## 13. 연락처 및 기여

프로젝트 관리자: [GitHub 사용자명]
이슈 보고: GitHub Issues 섹션 활용

---

**문서 작성일**: 2024-12-06
**프로젝트 버전**: 1.0 (프로덕션 준비)
**마지막 업데이트**: 2024-12-06
